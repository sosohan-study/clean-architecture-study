# 함수형 프로그래밍 

여러가지 의미로, 함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다.    
이 패러다임에서 핵심이 되는 기반은 람다 계산법이다.     
   
# 불변성과 아키텍처  
  
함수형 언어에서 변수는 변경되지 않는다.  

* 아키텍처를 고려할 때 이러한 내용이 왜 중요한가?    
* 아키텍트는 왜 변수의 가변성은 염려하는가?   

Race Condition, Dead Lock 조건, 동시성 업데이트 문제가 모두 가변 변수로 인해 발생하기 때문이다.           
만약, 어떠한 변수도 갱신되지 않느다면 경합 조건이나 동시 업데이트 문제가 일어나지 않는다.     
락이 가변적이지 않다면 교착 상태도 일어나지 않는다.     
    
다시 말해, 동시성 애플리케이션에서 마주치는 모든 문제      
즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는    
가변 변수가 없다면 절대로 생기지 않는 문제들이다.   
    
아키텍트라면 동시성 문제에 지대한 관심을 가져야만 한다.      
우리는 스레드와 프로세스가 여러 개인 상황에서도 설계한 시스템이 여전히 강건하기를 바란다.     
그렇다면 이제 분션성이 정말로 실현 가능한지를 스스로에게 반드시 물어봐야한다.  
     
이 질문에 대한 대답은 대체로 긍적적이다.          
단, 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제한다면 말이다.      
자원이 무한대가 아니라면 대답은 조금 미묘하다.    
그래 불변성은 실현가능하겠지만 일종의 타협을 해야한다.      

# 가변성의 분리 
  
불변성과 관련하여 가장 주요한 타협 중 하나는      
애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.         
불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.      
불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신하다.  

상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로,   
흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.   

트랜잭션 메모리는 데이터베이스가 디스크의 레코드를 다루는 방식과 동일한 방식으로 메모리의 변수를 처리한다.   
즉, 트랜잭션을 사용하거나 또는 재시도 기법을 통해 이들을 보호한다.(volatile이나 atomic)     
 
atom(atomic) 기능은 간단한 애플리케이션에서는 적합하다.     
하지만 안타깝게도 여러 변수가 상호 의존하는 상황에서는 동시 업데이트와 교착상태 문제로부터 완벽히 보호해주지 못한다.   
이러한 상황에서는 더 정교한 장치를 사용해야한다.   

말하려는 요지는, 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야한다는 것이다.  
그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야한다.    
  
현명한 아키텍트라면   
가능한 한 많은 처리를 불변 컴포넌트로 옮겨야하고,   
가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야한다.  

# 이벤트 소싱 
  
저장 공간과 처리 능력의 한계는 우리의 시야에서 급격히 사라지고 있다.           
이제 프로세서가 초당 수십억개의 명령을 수행하고 램 용량은 수십억 바이트인 시대가 되었다.        
더 많은 메모리를 확보할 수록, 기계가 더 빨라질수록, 필요한 가변 상태는 더 적이진다.     
  
고객의 계좌 잔고를 관리하는 은행 애플리케이션을 생각해보자.        
이 애플리케이션에서는 입금 트랜잭션과 출금 트랜잭션이 실행되면 잔고를 변경해야한다.    
   
이제 계좌 잔고를 변경하는 대신, 트랜잭션 자체를 저장한다고 생각해보자        
누군가 잔고 조회를 요청할때 마다 계좌 개설 시점부터 발생한 모든 트랜잭션을 단순히 더한다.      
이 전략에서는 가변 변수가 하나도 필요없다.    
 
당연하게도 이러한 접근법은 터무니 없다.       
시간이 지날수록 트랜잭션 수는 끝없이 증가하고, 잔고 계산에 필요한 컴퓨팅 자원은 걷잡을 수 없이 커진다.      
따라서 이 전략이 영원히 실현 가능하려면 무한한 저장 공간과 무한한 처리 능력이 필요하다.   
   
하지만, 이 전략이 영원히 동작하도록 만들 필요는 없다.      
**아마도 애플리케이션의 수면주기 동안만 문제없이 동작할 정도의 저장 공간과 처리 능력만 있으면 충분할 것이다.**     
  
**이벤트 소싱에 깔려있는 기본 발상이 바로 이것이다.**     
이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다.     
상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.   
  
물론, 지름길을 택할수도 있다.     
매일 자정에 상태를 계산한 후 저장하고 이후 상태 정보가 필요해지면 자정 이후의 트랜잭션만을 처리하면 된다.    
  
이제 이 전략에 필요한 데이터 저장소에 대해 생각해보자    
아마 저장 공간이 많이 필요할 것이다.     
실제로 오프라인 데이터 저장소는 급격하게 증가하여 이제는 수 테라바이트도 작다고 여기는 시대이다.   
따라서 우리는 저장 공간을 충분히 확보할 수 있다.    
  
더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다.     
결과적으로 애플리케이션은 CRUD가 아니라, 그저 CR만 수행한다.     
또한 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.  

저장 공간과 처리 능력이 충분하다면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.    
이 이야기가 터무니 없게 들린다면, 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다는 사실을 떠올려 보면 도움이 될 것이다.  

# 결론 

* 구조적 프로그래밍 : 제어흐름의 직접적인 전환에 부과되는 규율이다.   
* 객체 지향 프로그래밍 : 제어흐름의 간접적인 전환에 부과되는 규율이다.    
* 함수형 프로그래밍 : 변수 할당에 부과되는 규율이다.   
 
이들 세 패러다임 모두 우리에게서 무언가를 앗아갔다.        
각 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다.      
어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지 않는다.    
  
지난 반세기 동안 우리가 배운 것은 해서는 안 되는 것들에 대해서다.        
이 사실을 깨닫는다면 소프트웨어는 급격히 발전하는 기술이 아니라는 진실과 마주하게 된다.      
 
전자식 컴퓨터에서 실행할 거의 최초의 코드에서 사용한 소프트웨어 규칙과 지금의 소프트웨어 규칙은 조금도 다르지 않다.      
도구는 달라졌고 하드웨어도 변했지만, 소프트웨어 핵심은 여전히 그대로다.    
  
소프트웨어, 즉 프로그램은 `순차`, `분기`, `반복`, `참조`로 구성된다.      
그 이상도 그 이하도 아니다.    
