# 구조적 프로그래밍 

# 증명  
  
데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵다는 것이다.         
모든 프로그램은 단순할지라도, 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다.       
아주 작은 세부사항이라도 간과하면 프로그램이 동작하는 것처럼 보이더라도 결국엔 예상 외의 방식으로 실패하곤 했다.  

데이크스트라는 유클리드 계층 구조를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었다.     
즉, 프로그래머는 입증된 구조를 이용하고 이들 구조를 코드와 결합시키며 그래서 코드가 올바르다는 사실을 스스로 증명되는 방식이다.   

당연하게도 이렇게 하려면 단순한 알고리즘에 대해 기본적인 증명을 작성할 수 있는 기법을 보여줘야 한다는 사실을 깨달았다.    
데이크스트라는 이 연구를 진행하면서, goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 것을 발견했다.   
goto문장을 사용하면, 합리적으로 증명할 때 필수 기법인 분할 정복 접근법을 사용할 수 없어 모듈을 분해할 수 없다는 것을 발견했다.   

물론, goto 문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우도 있었다.    
데이크스트라는 이런 goto문의 좋은 사용 방식은    
`if/then/else`와 `do/while`과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견했다.    
**모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화하는 것이 가능해보였다.**  
데이크스트라는 제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다.  
     
뵘과 야코파니는 모든 프로그램을 순차, 분기, 반복이라는 세가지 구조만으로 표현할 수 있다는 사실을 증명했다.     
즉, **모듈을 증명하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다.**     
구조적 프로그래밍은 이렇게 탄생했다.   

데이크스트라는 단순한 열거법을 이용해 순차 구문이 올바름을 입증할 수 있다는 사실을 증명했다.     
 
**분기의 경우,** 열거법을 재적용하는 방식으로 처리했다.     
먼저 분기를 통한 각 경로를 열거하고 두 경로가 수학적으로 적절한 결과를 만들어낸다면, 증명은 신뢰할 수 있다.     

**반복의 경우,** 올바름을 증명하기 위해 귀납법을 사용했다.   
열거법에 따라 1의 경우가 올바름을 증명했고 N의 경우가 올바르다고 가정할 때도 열거법을 사용하여 N+1의 경우도 올바름을 증명했다.    
또한 반복의 시작 조건과 종료 조건도 열거법을 통해 증명했다.     
 
이 증명은 고되고 복잡했지만 증명은 증명이었다.     
이 증명을 해냄으로써 프로그램에서도 정리에 대한 유클리드 계층구조를 만들 수 있을 거라는 생각이 실제로 이루어질 듯 보였다.    
그리고 이를 통해 `goto문의 해로움`이라는 잡지에 실어 프로그래밍 세계에 불을 붙였다.     
   
여러 논쟁도 오고 갔지만, 컴퓨터 언어가 진화하면서 goto문의 필요성은 점점 사라졌다.     
현재의 우리 모두는 구조적 프로그래머이며, 여기에는 선택의 여지가 없다.     
제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.     
  
자바의 경우, break문이나 예외처리가 goto와 비슷하다고 볼 수 있지만,     
제어흐름을 아무 제약없이 직접 전환할 수 있던 과거 언어들과는 다르다.    
현재는 goto 키워드를 지원하는 언어에서도 goto문의 목적지 범위를 함수 안으로 한정시키는 편이다.  
   
# 기능적 분해 

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었다.    
이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻이다.    
     
거대한 기술서를 받더라도 고수준의 기능들로 분해할 수 있으며         
이들 각 기능은 다시 저수준의 함수들로 분해할 수 있고 이러한 분해 과정을 끝없이 반복할 수 있다.        
게다가 이렇게 부냏한 기능들은 구조적 프로그래밍의 제한도니 제어 구조를 이용하여 표현할 수 있다.  
 
이들을 토대로, 구조적 분석과 구조적 설계는 1970~1980년대까지 인기를 끌었다.    
더불어, 개발자들은 이 기법을 개선하고 널리 알렸다.      
이들의 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고       
더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.         

# 엄밀한 증명은 없었다.   

하지만, 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다.      
그리고 대개의 프로그래머들은 세세한 기능 하나하나를 엄밀히 증명하는 고된 작업에서 이득을 얻으리라고 보지 않았다.    
결국 데이크스트라의 꿈은 빛이 바랬고, 사라져버렸다.  
오늘 날 이처럼 엄밀한 증명이 고품질의 소프트웨어를 생성하기 위한 적절한 방법이라고 믿는 프로그래머는 이제 거의 없다.     

다행히도 무언가가 올바른지를 입증할 때 사용하는 전략에 유클리드 방식같이 엄밀한 수학적인 증명만이 있는 것은 아니다.   
상당히 성공한 또 다른 전략으로는 과학적 방법이 있다.  

# 과학이 구출하다.    
과학 이론과 법칙은 그 올바름을 절대 증명할 수 없다.     
이 점이 바로 과학적 이론과 법칙이 지닌 본성이다.       
즉, 과학적 방법은 반증은 가능하지만 증명은 불가능하다.   

과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작한다.     
각고의 노력으로도 반례를 들 수 없는 서술이 있다면 목표에 부합할 만큼은 참이라고 본다.   

결론적으로 수학은 증명 가능한 서술이 참임을 입증하는 원리라고 볼 수 있다.     
반면 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있다.      

# 테스트 
    
데이크스트라는 `테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.`고 말했었다.       
다시 말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.     
테스트에 충분한 노력을 들였다면 테스트가 보장할 수 있는 것은     
프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다.      
 
이 같은 사실이 내포하는 의미는 너무도 충격적이다.      
소프트웨어 개발이 수학적이게 보여도 사실은 과학적인 것이기 때문이다.      
최선을 다하더라도 올바르지 않음을 증명하는데 실패함으로써 올바름을 보여주기 때문이다.  
  
이러한 부정확함에 대한 증명은 입증 가능한 프로그램에만 적용할 수 있다.      
예를들어, goto문을 사용하는 등의 이유로 입증이 불가능한 프로그램은 테스트를 아무리 많이 수행하더라도 절대로 올바르다고 볼 수 없다.    
  
구조적 프로그램은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 가용한다.       
그리고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.       
이처럼 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.  

# 정리 
구조적 프로그래밍이 오늘날까지 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어낼 수 있는 능력 덕분이다.    
뿐만 아니라 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 한다.     

가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지     
모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.    
 
소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야한다.      
이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야한다.     
