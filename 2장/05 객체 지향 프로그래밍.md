# 객체 지향 프로그래밍 

좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데서 출발한다.  

ObjectOriented 란, 무엇인가에 대해 아래와 같이들 대답한다.  

* 데이터와 함수의 조합 : 
     * 엄청 옛날부터 프로그래머는 데이터 구조를 함수에 전달했기 때문에 이 개념은 아니다.  
* 실제 세계를 모델링하는 새로운 방법 : 
     * 현실 세계와 의미적으로 가깝기 때문에 사용한다.    
     * 하지만, 꼭 실제 세계만 모델링해야하는지 그리고 의도도 불분명하다.  

위 같은 대답은 객체지향에 대한 오해를 불러일으킬 수 있고 뜻도 명확하지 않다.   

ObjectOriented의 본질을 설명하기 위해 아래 3가지가 필요하다고 말을 하기도 한다.   

1. 캡슐화 
2. 상속 
3. 다형성 

# 캡슐화? 

데이터와 함수를 쉽고 효과적으로 모으는 방법     
ObjectOriented 언어들은 이러한 캡슐화 방법을 제공해준다.    

캡슐화를 사용하면, 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.       
구분선 바깥에서는 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.(private 필드, public 메서드)       
**즉, 외부에서는 데이터 구조와 함수가 어떻게 구현되었는지에 대해서 조금도 알지 못하고 그냥 사용만 하면 된다.**    
이것이 바로 완벽한 캡슐화이며, ObjectOriented가 아닌 언어에서도 충분히 구현 가능하다.   

언어에 pulic, private, protected 키워드를 도입함으로써 불완전한 캡슐화를 어느정도 보완하기는 했다.    
하지만 이는 컴파일러가 헤더 파일에서 멤버 변수를 볼 수 있어야 했기 때문에 조치한 임시방편일 뿐이다.      

자바와 C#은 헤더와 구현체를 분리하는 방식을 모듀 벼렸고, 이로인해 캡슐화는 더욱 심하게 훼손되었다.     
이들 언어에서는 클래스 선언과 정의를 구분하는게 아예 불가능하다.    

이 때문에 ObjectOriented가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다.   
실제로 많은 ObjectOriented 언어가 캡슐화를 거의 강제한지는 않는다.   

ObjectOriented 프로그램이은 프로그래머가 충분히 올바르게 행동함으로써     
캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿을 기반으로 한다.  
하지만, ObjectOriented 를 제공한다고 주장한 언어들이 실제로는 완벽한 캡슐화를 약화시켜온 것은 틀림없다.   

# 상속? 

ObjectOriented 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속 만큼은 ObjectOriented 언어가 확실히 제공했다.   
상속이란, 단순히 어떤 변수와 함루를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.   
  
ObjectOriented 언어가 고안되기 훨씬 이전에도 상속과 비슷한 기법이 사용되고 있었다.     
하지만, 이렇게 말하는 데는 어폐가 있다.     
상속을 흉내내는 요렁은 있었지만, 사실상 상속만큼 편리한 방식은 절대 아니기 때문이다.     
게다가 이 기법을 이용해서 다중 상속을 구현하기란 훨씬 더 어려운 일이었다.      

ObjectOriented 언어가 완전히 새로운 개념을 만든 것은 아니지만,     
데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공햇다고 볼수는 있다.    

간략히 요약하자면, ObjectOriented에    
캡슐화에 대해서는 점수를 줄 수 없고       
상속에 대해서만 0.5점 정도를 부여할 수 있다.   

# 다형성? 

ObjectOriented 언어가 있기 이전에 다형성을 표현할 수 있는 언어도 존재하기는 했다.       
말하려는 요지는, 함수를 가리키는 포인터를 응용한 것이 다형성이라는 점이다.         
즉, 다형성은 ObjectOriented 가 새롭게 고안한 개념은 아니라는 것이다.     
  
ObjectOriented 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.     
 
함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식에는 문제가 있는데     
함수 포인터는 위험하다는 사실이다.        
이러한 기법은 프로그래머가 특정 관례를 수동을 따르는 방식이다.            
즉, 이들 포인터를 초기화하는 관례를 준수해야 한다는 사실을 기억해야한다.        
그리고 이들 포인터를 통해 모든 함수를 호출하는 관례를 지켜야한다는 점도 기억해야한다.      
만약 프로그래머가 관례를 지켜야한다는 사실을 망각하게 되면 버그가 발생하고, 이러한 버그는 찾아내고 없애기가 지독히도 힘들다.    
  
ObjectOriented 언어는 이러한 관례를 없애주며, 따라서 실수할 위험이 없다.       
ObjectOriented 언어를 사용하면 다형성은 대수롭지 않은 일이 된다.      
ObjectOriented 언어는 과거 C프로그래머가 꿈에서 볼 수 있던 강력한 능력을 제공한다.      
이러한 이유로 ObjectOriented는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.  

## 다형성이 가진 힘
  
기존 흑백 프린터에서 컬러 프린터로 바꾼다고 가정을 하겠다.        
프린터를 바꿨다고 해서 프린트 프로그램을 새로 설치하지 않고 그냥 하던대로 프린트를 하면 된다.  
다시 말해 프린트 입출력 드라이버가 프린트 프로그램의 플러그인이 된 것이다.   
이것이 바로 다형성이 가진 힘이며 장점이다.   
   
플러그인 아키텍처는 이처럼 독립성을 지원하기 위해 만들어졌다.        
OS의 입출력 장치부터 여러곳에서 사용되었는데 그럼에도 프로그램에서는 이러한 개념을 적용하지 않았었다.     
함수를 가리키는 포인터를 사용하면 위험을 수반하기 때문이었다.     

하지만, ObjectOriented 의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.    

## 의존 역전의 원칙 

<img width="696" alt="5_1" src="https://user-images.githubusercontent.com/50267433/149611769-ebd443bb-eb62-4362-b2cf-4b86425c684c.png">

다형성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 전 소프트웨어의 모습은 위와 같았다.      
전형적인 호출 트리의 경우 main 함수가 고수준 함수를 호출하고,       
고수준 함수는 다시 중간 수준 함수를 호출하고, 중간 수준 함수는 다시 저수준 함수를 호출한다.       
이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다.       

**실제로 모든 호출 함수는 피호출 함수가 포함된 모듈의 이름을 명시적으로 지정해야한다.**     
이러한 제약조건으로 인해 소프트에어 아키텍트에게 남은 선택지는 별로 없었다.       
즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.     

![다운로드 (1)](https://user-images.githubusercontent.com/50267433/149611842-12e62fee-8708-47bb-b2ca-ee43fbc256b9.png)

하지만 다형성이 끼어들면 무언가 특별한 일이 일어난다.       
소스 코드 의존성이 제어 흐름과는 반대임 점을 주목하자.    
이는 의존성 역전이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 갖는다.   
  
소스 코드 의종선은 소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.    
즉, ObjectOriented 언어가 다형성을 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이다.      
  
ObjectOriented 언어로 개발된 시스템을 다루느 소프트웨어 아키텍트는       
시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다.     
즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지는 않는다.    
**호출하는 모듈이든 아니면 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향을 설정할 수 있다.**    
이것이 바로 ObjectOriented 가 제공하는 힘이며 ObjectOriented 가 지향하는 것이다.     

<img width="709" alt="5_3" src="https://user-images.githubusercontent.com/50267433/149612239-f63c8e85-74fc-4a3f-bd72-fdc042377161.png">
  
비즈니스 로직이 데이터 베이스와 사용자 인터페이스에 의존하는 대신에,    
시스템의 소스 코드 의존성을 반대로 배치하여 데이터베이스와 UI가 비즈니스 로직에 의존하게 만들었다.       
   
즉, UI와 데이터베이스가 비즈니스 로직의 플러그인이 된다는 뜻이다.         
다시 말해, 비즈니스 로직에는 UI나 데이터베이스를 호출하지 않는다.      

결과적으로 비즈니스 로직, UI, 데이터베이스는 3가지로 분리된 컴포넌트 또는 배포 가능한 단위로 컴파일할 수 있고      
이 배포 단위들의 의존성 역시 소스 코드 사이의 의존성과 같다.      
따라서 비즈니스 로직을 포함하는 컴포넌트는 UI와 데이터베이스를 포함하는 컴포넌트에 의존하지 않는다.    
    
비즈니스 로직을 UI와 데이터베이스에 독립적으로 배포할 수 있으며        
UI나 데이터베이스에서 발생한 벼경사항은 비즈니스 로직에 일정 영향을 미치지 않는다.    
즉, 이들 컴포넌트는 개별적이며 독립적으로 배포가 가능하다.    
  
다시 여러번 말하지만, 특정 컴포넌트의 소스 코드가 변경되면 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다.     
이것이 바로 배포 독립성이다.     
  
시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다.    
그리고 이 것이 개발 독립성이다.    

# 정리 

소프트웨어 아키텍트 관점에서 정답은 명백하다.  
ObjectOriented 란 다형성을 이용하여    
전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.     
     
ObjectOriented를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고,      
이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.     
저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.      
저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고,     
고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.     
















