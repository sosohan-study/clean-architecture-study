# 설계 원칙 

좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작한다.    
 
좋은 코드를 사용하지 않으면 아키텍처가 좋고 나쁨은 그리 큰 의미가 없다.         
하지만, 좋은 코드를 사용하더라도 아키텍처를 엉망으로 만들 수 있다.       
**그렇기 때문에, 좋은 코드로 좋은 아키텍처를 정의하는 원칙이 필요하다.**     

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법,    
그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.     
  
'클래스'를 사용했다고 해서 단순히 OOP에만 적용되는 것은 아니다.    
여기에서 '클래스'는 단순히 함수와 데이터를 결합한 집합을 의미하기 때문이다.     
소프트웨어 시스템은 모두 이러한 집합을 포함하며, SOLID 원칙은 이러한 집합에 적용된다.  

SOLID 원칙의 목적은 '중간 수준'의 소프트웨어 구조가 아래와 같도록 만드는데 있다.   
  
* 변경에 유연하다.     
* 이해하기 쉽다.    
* 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이된다.  

'중간 수준'이란, 프로그래머가 이들 원칙을 모듈 수준에 작업할 때 적용할 수 있다는 뜻이다.  
즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다.  

SOLID 원칙에 대한 간략한 설명은 아래와 같다.     
 
**SRP: 단일 책임 원칙**     
* 콘웨이 법칙에 따른 정리   
* 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다.    
* 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.    

**OCP: 개방 폐쇄 원칙**   
* 기존 코드를 수정하기 보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계한다.   
* 이렇게 해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.   

**LSP: 리스코프 치환 원칙**   
* 하위 타입에 관한 유명한 원칙이다.   
* 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면,     
* 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야한다.   
* 상위 타입에 요소를 하위 타입들이 IS-A 관계로 모두 만족해야한다는 의미기도 하다.  

**ISP: 인터페이스 분리 원칙**  
* 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.     
* 인터페이스가 비대하면, 사용하지 않는 메서드들이 존재한다.       
* 인터페이스를 작은 단위로 분리하고 이들을 HAS-A 관계로 추가하면서 사용하자는 의미기도 하다.    

**DIP: 의존성 역전 원칙**   
* 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존하면 안된다.   
* 대신 세부사항이 정책에 의존해야한다.(추상화 이용해서)  







