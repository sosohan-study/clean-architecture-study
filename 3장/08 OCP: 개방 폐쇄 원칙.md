# OCP: 개방 폐쇄 원칙  

```
소프트웨어 개체는 확장에는 열려 있어야하고, 변경에는 닫혀 있어야한다.    
```  
다시 말해, 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.       

**소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문이다.**    
만약 요구사항을 살짝 확장하는데 소프트웨어를 엄청나게 수정해야한다면,        
그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨릴 것이다.    

소프트웨어 설계를 공부하기 시작한지 얼마 안 된 사람들 대다수는 OCP를 클래스와 모듈을 설계할 때 도움이 되는 원칙이라 알고 있다.    
**하지만, 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가진다.**     
사고 실험을 해보면 이점이 분명해진다.    

# 사고 실험 

기존 작업 방식에서, 새로운 요구사항이 들어와 기능을 추가해야한다고 가정한다.       
소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 한 최소화 될것이다.(이상적인 변경량은 0이다)     

서로 다른 목적으로 변경되는 요소를 적절하게 분리하고(SRP),      
이들 요소 사이의 의존성을 체계화함으로써(DIP)     
변경량을 최소화할 수 있다.   
   
![사고실험이미지](https://user-images.githubusercontent.com/50267433/149616473-fbc83fa5-9e13-4739-b757-774efd394c2e.png)
  
단일 책임 원칙(SRP)를 적용하면 데이터 흐름을 위와 같은 형태로 만들 수 있다.       
재무 데이터를 검사한 후 보고서용 데이터를 생성한다음, 필요에 따라 2가지 생성 절차중 하나를 걸쳐 포매팅하면 된다.      

여기서 얻을 수 있는 가장 중요한 영감은 **보고 생성이 두 개의 책임으로 분리된다는 사실이다.**   
   
* 하나는 보고서용 데이터를 계산하는 책임   
* 하나는 데이터를 웹으로 보여주거나 종이로 프린트하기에 적합한 형태로 표현하는 책임   

이처럼 책임을 분리했다면,     
**두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다.**       
**또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야한다.**       

![image](https://user-images.githubusercontent.com/50267433/149616582-6b2ffcd8-8c1c-4e05-8bd4-3a86d7aafb19.png)
 
이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고,       
이들 클래스를 위와 같이 이중선으로 표시한 컴포넌트 단위로 구분해야한다.    
위 그림에서는 좌측 상단의 컴포넌트는 Controller 다.    
우측 상단에서는 Interactor 컴포넌트를, 우측 하단에서는 Database 컴포넌트를 볼 수 있다.    
좌측 하단에는 Presenter 와 View를 담당하는 네가지 컴포넌트가 위치한다.     

* `<I>` : 인터페이스
* `<DS>` : 데이터 구조 클래스
* 열린 화살표 : 사용 관계
* 닫힌 화살표 : 구현 관계 또는 상속 관계  

여기서 주목할 점은, 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다.    
구현 관계를 통해서 특정 클래스가 다른 클래스를 알고있지만, 역으로는 알고 있지 못한다.    

![이중선](https://user-images.githubusercontent.com/50267433/149616695-9a6f455d-6be6-4b1a-bb5b-c5c26362725d.png)

여기서 주목해야할 또 다른 점은 이중선은 화살표와 오직 한 방향으로만 교차한다는 사실이다.    
모든 컴포넌트 관계는 단반향으로 이루어진다는 뜻이다.       
이들 화살표는 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다.  

다시 한번 말하지만, A컴포넌트에서 발생한 변경으로부터 B컴포넌트를 보호하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야한다.   
`Interactor` 를 보면, 아무런 의존성을 가지지 않는 특별한 위치를 차지하고 있는 것을 볼 수 있다.    
`Interactor` 는 비즈니스 로직을 포함하고 있기에 가장 높은 수준의 정책을 포함한다.   

`Interactor` 이외의 컴포넌트는 모두 주변적인 문제를 처리한다.   
가장 중요한 문제는 `Interactor`가 담당한다.    

보호 계층구조가 '수준(level)'이라는 개념을 바탕으로 어떻게 생성되는지 주목하자.        
`Interactor`는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다.           
`View`는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다.         
`Presenter`는 `View`보다는 높고 `Controller` 나 `Interactor`보다는 낮은 수준에 위치하고 있다.      

이것이 바로 아키텍처 수준에서 OCP가 동작하는 방식이다.    
아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고,     
분리한 기능을 컴포넌트의 계층 구조로 조직화한다.     
  
컴포넌트 계층 구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.     

# 방향성 제어  
 
![이중선](https://user-images.githubusercontent.com/50267433/149616695-9a6f455d-6be6-4b1a-bb5b-c5c26362725d.png)

위 다이어그램은 일부러 다소 복잡하게 그렸는데,     
컴포넌트 간 의존성이 제대로 된 방향으로 향하고 있음을 확실히 보여주기 위해서이다.    
의존성을 역전시킨 모습도 보여진다.(FinancialDataGateway)         
 
# 정보 은닉  

방향성 제어와는 달리, 정보 은닉의 목적을 가지기도한다.(FinancialReportRequester)  
만약 FinancialReportRequester 가 없다면 Controller는 FinancialEntities 에 대해 추이 종속성을 가지게된다.    

추이 종속성을 가지게 되면,     
소프트웨어 엔티티는 `자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안된다.`는 소프트웨어 원칙을 위반하게 된다.    
   
다시 말해서, `Controller`에서 발생한 변경으로부터 `Interactor`를 보호하는 일의 우선순위과 가장 높지만,      
반대로 `Interactor`에서 발생한 변경으로부터 `Controller`도 보호되기를 바란다.       
이를 위해 `Interactor` 내부를 은닉한다.     

# 결론 
   
OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다.      
OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있다.       
이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고,      
저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야한다.     
