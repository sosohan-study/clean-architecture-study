# SRP: 단일 책임 원칙

SOLID 원칙 중에서 그 의미가 가장 잘 전달되지 못한 원칙이다.       
모든 모듈이 단 하나의 일만 해야한다는 의미로 받아들이기 쉬운데 이는 절대 아니다.      

```
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.   
``` 

소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.   
SRP가 말하는 '변경의 이유'란 바로 이들 사용자와 이해 관계자를 가리킨다.   

```
하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임을 지어야한다.   
``` 
  
안타깝게도 '사용자'와 '이해 관계자'라는 단어를 여기에 쓰는 것은 사실 올바르지 않다.     
시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자가 두 명 이상일 수도 있기 때문이다.     
여기서는 기존 의미보다는 `집단(액터)`, 즉 해당 변경을 요청하는 한명 이상의 사람을 가리킨다.     

```
하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야한다.  
```  

**그럼 모듈이라는 뜻은 무엇일까?🤔**       
가장 단순한 정의는 바로 소스파일이다.      
대부분의 경우 잘 들어맞지만 소스파일에 저장하지 않는 언어와 개발 환경의 경우를 따지면     
**모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.**   

**응집된**이라는 단어가 SRP를 암시한다.    
단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.    

# 징후 1: 우발적 중복 

![우발적 중복](https://user-images.githubusercontent.com/50267433/149615179-997118c6-ad58-46a4-818b-53d54a515b97.png)
 
Employee 클래스를 예시로 선정한다.         
클래스에 존재하는 각각의 메서드는 CFO, COO, CTO 들이 사용하는 메서드다.         
즉, 하나의 클래스에 여러 `액터(사용자/이해관계자)` 와 묶여있는 것을 알 수 있다.      

* calculatePay() : 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.    
* reportHours() : 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.   
* save() : 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.   
  
개발자가 이 3메서드를 단일 클래스에 배치하여 3액터가 서로 결합되어버렸다.      
이 결합으로 인해 CFO 팀에서 결정한 조치가 COO/CTO팀에 의존하는 무언가에 영향을 줄 수 있다.    

<img width="717" alt="7_2" src="https://user-images.githubusercontent.com/50267433/149615313-7e096b76-a119-4e6e-ae8a-1829a3a16845.png">

* `calculatePay()`와 `reportHours()`가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 가정한다.    
* 개발자는 코드 중복을 피하기 위해 `regularHours()` 라는 메서드를 만들어 공통으로 호출하도록 넣었다.  
* 즉 `calculatePay()`와 `reportHours()`는 초과 근무 측정을 위해 `regularHours()`를 호출하는 구조다.          

CFO 팀에서, 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 결정했다고 가정한다.       
COO 팀에서, 초과 근무를 제외한 업무 시간을 다른 목적으로 사용하기 때문에, 변경을 원치않는다고 가정한다.   

CFO 팀에서의 변경 작업을 처리하는 개발자는 `regularHours()`를 호출한다는 사실을 깨닫고 이를 수정한다.   
다만, 본인의 팀인 `calculatePay()`에서의 호출은 알아도 COO팀의 `reportHours()`에서 호출하는 건 모른다.   
즉, 요청사항으로 인해 변경 작업을 처리했는대 COO팀의 로직에도 영향을 주어 시스템을 망가뜨리게 만들었다.   

이러한 문제는 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다.    
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.    

# 징후 2: 병합 

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하기는 어려운일이 아니다.    
특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 확실히 더 높다.   

DBA가 속한 CTO팀에서 데이터베이스의 Emplyoee 테이블을 스키마를 약간 수정하기로 결정했다고 가정한다.     
이와 동시에 인사 담당자가 속한 COO 팀에서는 `reportHours()`의 보고서 포맷을 변경하기로 결정했다고 가정한다.   
 
두 팀의 개발자는 Emplyoee 클래스를 체크아웃 받은 후 변경사항을 적용하기 시작한다.        
당연하게도, 이들의 변경사항은 충돌이 발생하며 결과적으로 병합이 발생한다.     
이 예에서 발생한 병합은 CTO와 COO 모두 곤경애 빠뜨린다.(CFO도 영향을 줄 수 있다.)   

살펴볼만한 징후가 더 있겠지만, 이들 징후는 모두 많은 사람이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우에 해당한다.    
다시 한번 말하지만, 이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.   

# 해결책  

이 문제의 해결책은 다양한데, 그 모두가 메서드를 각기 다른 클래스로 이동시키는 법이다.    
그리고 이 문제에 대해서만 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다.    

즉, 아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어, 3개의 클래스가 공유하도록 한다.        
각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함한다.(woozi -> 근데 이건 좀 의존성이 강하게 엮이지 않나..?)            
3 클래스는 서로의 존재를 몰라야하며, 따라서 '우연한 중복'을 피할 수 있다.   

![image (1)](https://user-images.githubusercontent.com/50267433/149615977-db3dadbd-3e7e-4fb6-bfda-62f2e637f115.png)

다만 앞서 소개했던 방식은 개발자가 3가지 클래스를 인스턴스화하고 추적해야한다는게 단점이다.    
이러한 난관에서 빠져나올 때 흔히 쓰는 기법으로 퍼사드 패턴이 있다.    

<img width="707" alt="7_4" src="https://user-images.githubusercontent.com/50267433/149615982-0aed4646-d306-4526-bd02-b91d59902d2b.png">

EmplyeeFacade 에 코드는 거의 없다.   
이 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.      

![세번째해결책](https://user-images.githubusercontent.com/50267433/149616079-02f82933-01d5-472f-8be5-34b9d65a992c.png) 

어떤 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다.        
이 경우라면 가장 중요한 메서드느 기존의 Employee 클래스에 그대로 유지하되,       
Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있다.     
(Employee 내에서 데이터를 필드로 가지고, 컴포지션으로 접근하는 방식을 의미한다.)  

모든 클래스는 반드시 단 하나의 메서드를 가져야 한다는 주장에 근거하여 앞의 해결책에 반대할 수도 있다.   
하지만 이주장은 현실과는 전혀 다르다.   
각 클래스에서 지불, 보고서 생성, 데이터 저장 기능을 구현하는데 필요한 메서드의 개수는 실제로 훨씬 더 많을 것이다.   
이들 클래스는 모두 다수의 private 메서드를 포함할 것이다.   

이처럼 여러 메서드가 하나의 가족을 이루고,  
메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다.   
해당 유효범위 바깥에서는 이 가족에게 감춰진(private 멤버)가 있는지를 전혀 알 수 없다. 

# 결론 
단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.     
하지만 이보다 상위 두 수준에서도 다른 형태로 다시 등장한다.      

컴포넌트 수준에서는 `공통 폐쇄 원칙`이 된다.      
아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.     









# 결론 







