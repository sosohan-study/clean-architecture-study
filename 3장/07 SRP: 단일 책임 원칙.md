# SRP: 단일 책임 원칙

SOLID 원칙 중에서 그 의미가 가장 잘 전달되지 못한 원칙이다.       
모든 모듈이 단 하나의 일만 해야한다는 의미로 받아들이기 쉬운데 이는 절대 아니다.      

```
단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.   
``` 

소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.   
SRP가 말하는 '변경의 이유'란 바로 이들 사용자와 이해 관계자를 가리킨다.   

```
하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임을 지어야한다.   
``` 
  
안타깝게도 '사용자'와 '이해 관계자'라는 단어를 여기에 쓰는 것은 사실 올바르지 않다.     
시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자가 두 명 이상일 수도 있기 때문이다.     
여기서는 기존 의미보다는 `집단(액터)`, 즉 해당 변경을 요청하는 한명 이상의 사람을 가리킨다.     

```
하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야한다.  
```  

**그럼 모듈이라는 뜻은 무엇일까?🤔**       
가장 단순한 정의는 바로 소스파일이다.      
대부분의 경우 잘 들어맞지만 소스파일에 저장하지 않는 언어와 개발 환경의 경우를 따지면     
**모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.**   

**응집된**이라는 단어가 SRP를 암시한다.    
단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.    

# 징후 1: 우발적 중복 

![우발적 중복](https://user-images.githubusercontent.com/50267433/149615179-997118c6-ad58-46a4-818b-53d54a515b97.png)
 
Employee 클래스를 예시로 선정한다.         
클래스에 존재하는 각각의 메서드는 CFO, COO, CTO 들이 사용하는 메서드다.         
즉, 하나의 클래스에 여러 `액터(사용자/이해관계자)` 와 묶여있는 것을 알 수 있다.      

* calculatePay() : 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.    
* reportHours() : 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.   
* save() : 데이터베이스 관리자가 기능을 정의하고, CTO 보고를 위해 사용한다.   
  
개발자가 이 3메서드를 단일 클래스에 배치하여 3액터가 서로 결합되어버렸다.      
이 결합으로 인해 CFO 팀에서 결정한 조치가 COO/CTO팀에 의존하는 무언가에 영향을 줄 수 있다.    

<img width="717" alt="7_2" src="https://user-images.githubusercontent.com/50267433/149615313-7e096b76-a119-4e6e-ae8a-1829a3a16845.png">

* `calculatePay()`와 `reportHours()`가 초과 근무를 제외한 업무 시간을 계산하는 알고리즘을 공유한다고 가정한다.    
* 개발자는 코드 중복을 피하기 위해 `regularHours()` 라는 메서드를 만들어 공통으로 호출하도록 넣었다.  
* 즉 `calculatePay()`와 `reportHours()`는 초과 근무 측정을 위해 `regularHours()`를 호출하는 구조다.          

CFO 팀에서, 초과 근무를 제외한 업무 시간을 계산하는 방식을 약간 수정하기로 결정했다고 가정한다.       
COO 팀에서, 초과 근무를 제외한 업무 시간을 다른 목적으로 사용하기 때문에, 변경을 원치않는다고 가정한다.   

CFO 팀에서의 변경 작업을 처리하는 개발자는 `regularHours()`를 호출한다는 사실을 깨닫고 이를 수정한다.   
다만, 본인의 팀인 `calculatePay()`에서의 호출은 알아도 COO팀의 `reportHours()`에서 호출하는 건 모른다.   
즉, 요청사항으로 인해 변경 작업을 처리했는대 COO팀의 로직에도 영향을 주어 시스템을 망가뜨리게 만들었다.   

이러한 문제는 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다.    
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.    

# 징후 2: 병합 

소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작하기는 어려운일이 아니다.  






