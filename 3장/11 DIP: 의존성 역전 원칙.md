# DIP: 의존성 역전 원칙

의존성 역전 원칙에서 말하는 **유연성이 극대화된 시스템**이란,     
소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.    

정적 타입 언어에서의 이말은 `use`, `import`, `include`와 같은 구문은     
오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻이기도 하다.          
**구체적인 대상에는 절대로 의존해서는 안 된다**     
      
동적 타입 언어에도 동일한 규칙이 적용된다.      
소스 코드 의존 관계에서 구체 모듈은 참조해서는 안 된다.       
하지만 이들 언어의 경우 구체 모듈이 무엇인지를 정의하기가 다소 어렵다.     
호출할 함수가 구현된 모듈이라면 참조하지 않기가 특히 어렵다.    
 
이 아이디어를 규칙으로 보기는 확실히 비현실적이다.    
소프트웨어 시스템이라면 구체적인 많은 장치를 반드시 의존해야하기 때문이다.     
자바에서는 String 타입이 있는데 이는 구체 클래스이며, 이를 애써 추상클래스로 만들려는 시도는 현실성이 없다.       
즉, String 구체 클래스에 대한 소스 코드 의존성은 벗어날 수 없고, 벗어나도 안된다.   
   
String 클래스는 매우 안정적이다.      
String 클래스가 변경되는 일은 거의 없으며, 있더라도 엄격하게 통제된다.       
프로그래머와 아키텍트는 String 클래스에서 변덕스러운 변경이 자주 발생하리라고 염려할 필요가 없다.   

이러한 이유로 DIP를 논할 때, **운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다.**     
우리는 이들 환경에 대한 의존성은 용납하는데, 변경되지 않는다면 의존할 수 있다는 사실을 이미 알고 있기 때문이다.  
  
**우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소이다.**        
그리고 이 구체적인 요소는 우리가 열심히 개발하는 중이라 **자주 변경될 수 밖에 없는 모듈들이다.**    

# 안정된 추상화 

추상 인터페이스에 변겨이 생기면 이를 구체화한 구현체들도 따라서 수정해야한다.     
반대로 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 변경될 필요가 없다.      
따라서 인터페이스는 구현체보다 변동성이 낮다.    

**뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 애쓴다.**        
**인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력한다.**           
**이는 소프트웨어 설계의 기본이다.**      
 
즉, 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일을 지양하고      
안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.     
이 원칙에서 전달하려는 내용은 다음과 같이 매우 구체적인 코딩 실천법으로 요약할 수 있다.   

* 변동성이 큰 구체 클래스를 참조하지 말라, 대신 추상 인터페이스를 참조하라  
    * 언어가 정적 타입이든 동적 타입이든 관계없이 모두 적용된다.       
    * 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다.  
* 변동성이 큰 구체 클래스로부터 파생하지 말라   
    * 정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경이 어렵다.  
    * 따라서 상속은 아주 신중하게 사용해야한다.  
    * 동적 타입언어라면 문제가 덜 되지만, 의존성을 가진다는 사실에는 변함이 없다.   
    * 따라서 신중에 신중을 거듭하는게 현명한 선택이다.   
* 구체 함수를 오버라이드 하지 말라   
    * 대체로 구체 함수는 소스 코드 의존성을 필요로 한다.   
    * 따라서 구체 함수를 오버라이드하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.   
    * 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에게 각자의 용도에 맞게 구현해야한다.  
* 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지말라   
    * 사실 이 실천법은 DIP 원칙을 다른 방식으로 풀어 쓴 것이다.     

# 팩토리

앞선 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야한다.    
이러한 점은 조심하는게 당연한데, 사실상 모든 언어에서 객체를 생성하려면     
해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생하기 때문이다.      

자바 등 대다수의 객체 지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.   

![120923232-6c906400-c708-11eb-9132-c6452d92541f](https://user-images.githubusercontent.com/50267433/149618873-be11b17d-0dae-4b2d-a480-ea1fbc4d67e0.png)

```
Application은 구현체 ConcreteImpl 을 사용한다.
이 과정에서 ConcreteImpl 의 추상화 인터페이스인 Service로 참조하고 있다.  

Service 하위 객체를 생성을 위해서 Service 를 상속한 ServiceFactory 인터페이스를 구현한 ServiceFactoryImpl을 사용한다.   
이 과정에서 ServiceFactoryImpl의 추상화 인터페이스인 ServiceFactory로 참조하고 있다.  
  
즉, Application은 ServiceFactoryImpl을 통해 ConcreteImpl 받아서 사용한다.  
```

추상 팩토리를 통해, 구현체를 생성하고 이를 참조하고 있는 모습이다.   
곡선은 아키텍처의 경계를 뜻한다.   
이 곡선은 구체적인 것들로부터 추상적인 것들을 분리한다.   
소스 코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다.   

곡선은 시스템을 2가지 컴포넌트로 분리한다.   

* 추상 컴포넌트 : 애플리케이션의 모든 고수준 업무 규칙을 포함한다.  
* 구체 컴포넌트 : 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다.   

제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목하자   
다시 말해 소스 코드 의조성은 제어흐름과는 반대 방향으로 역전된다.   
이러한 이유로 이 원칙을 의존성 역전 원칙(DIP)이라 부른다.    

# 구체 컴포넌트 

![120923232-6c906400-c708-11eb-9132-c6452d92541f](https://user-images.githubusercontent.com/50267433/149618873-be11b17d-0dae-4b2d-a480-ea1fbc4d67e0.png)
 
구체 컴포넌트에는 구체적인 의존성이 하나 있고, 따라서 DIP에 위배된다.(ServiceFactoryImpl)      
이는 일반적인 일이고 DIP 위배를 모두 없앨 수는 없다.       
하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포너늩 내부로 모을 수 있고 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.     

대다수의 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함할 것이다.     
흔히 이 컴포넌트를 메인이라고 부르는데, main 함수를 포함하기 때문이다.      

위의 경우라면 `ServiceFactoryImpl`의 인스턴스르 생성한 후,     
이 인스턴스를 `ServiceFactory` 타입으로 전역 변수에 저장할 것이다.      
그런 다음 `Application` 은 이 전역 변수를 이용해서 `ServiceFactoryImpl`의 인스턴스에 접근할 것이다.  

# 결론 

고수준의 아키텍처 원칙을 다루게 되면서 DIP는 몇번이고 등장한다.       
그리고 DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다.     
앞선 그림의 곡선은 아키텍처의 경계가 될 것이다.      
그리고 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향한다.     
  
추후 이 규칙은 **의존성 규칙**이라고 부를 것이다.        
