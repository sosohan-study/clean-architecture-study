# LSP: 리스코프 치환 원칙

바바라 리스코프는 하위 타입을 아래와 같이 정의했다.   

```
여기에서 필요한 것은 다음과 같은 치환 원칙이다.   
S 타입의 객체 각각에 대응하는 T타입 객체가 있고    
T 타입을 이용해서 정의한 모든 프로그램 P에서    
T타입 대신 S타입으로 치환해도 P의 행위는 변하지 않는다면, S는 T의 하위 타입이다.  
```

리스코프 치환 원칙으로 알려진 이 개념을 이해하기 위한 몇가지 예제를 살펴보자  
  
# 상속을 사용하도록 가이드하기   

![image](https://user-images.githubusercontent.com/50267433/149617273-a013452c-3f14-4c35-9c28-542005f369de.png)

License 클래스는 `calcFee()`를 가지며, Billing 애플리케이션에서 이 메서드를 호출한다.        
License 클래스의 하위 타입으로는 PersonalLincense와 BusinessLincense 라는 2가지 타입이 존재한다.     
이들 두 하위 타입은 서로 다른 알고리즘을 이용해서 라이선스 비용을 계산한다.     

Billing 애플리케이션의 행위가   
License 하위 타입중 무엇을 사용하는지에 전혀 의존하지 않기 때문에 이 설계는 LSP를 준수한다.       
이들 하위 타입은 모두 License 타입을 치환할 수 있다.     

# 정사각형/직사각형 문제 
LSP를 위반하는 전형적인 문제로는 유명한 `직사각형/정사각형 문제`가 있다.   

![리스코프2](https://user-images.githubusercontent.com/50267433/149617397-4b8739f5-48c2-43e9-a647-66ae4544660c.png)

Square(정사각형)는 Rectangle(직사각형)의 하위 타입으로는 적합하지 않은데     
Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면    
Square의 높이와 너비는 반드시 함께 변경되기 때문이다.    

```java
Rectangle r = new Square();
r.setW(5);
r.setH(2);
assert(r.area() == 10); -> 4가 나온다.  
```  
User는 대화하고 있는 상대를 Rectangle이라고 생각하므로 혼동이 생길 수 있다.     
  
이러한 문제를 해결하기 위해 Square인지 검사하는 매커니즘을 추가할 수 있지만     
이렇게 하면 User의 행위가 사용하는 타입에 의존하게 되므로 결국 타입을 서로 치환할 수 없게 된다.   

# LSP와 아키텍처   

객체 지향이 혁명처럼 등장한 초창기에는 LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주되었다.    
하지만 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모했다.    

여기서 말하는 인터페이스는 다양한 형태로 나타난다.   
자바스러운 언어라면 인터페이스 하나와 이를 구현하는 여러개의 클래스로 구성된다.   
또는 동일한 REST 인터페이스에 응답하는 서비스 집단일 수 있다.   

이상의 모든 상황은 물론 더 많은 LSP를 적용할 수 있다.   
잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환 가능성에 기대는 사용자들이 존재하기 때문이다.    

아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨일이 일어나는지 관찰하는 것이다.  

# LSP 위배 사례   

택시 업체끼리 공통으로 정의한 REST API에 대해서 치환 관계를 가지는데 이를 위배했다고 가정한다.   

```
purplecab.com/driver/Bob
    /pickupAddress/24 Maple St.
    /pickupTime/153
    /destination/ORD
```
위와 같이 `pickupAddress`, `pickupTime`, `destination` 필드를 통해 처리한다고 가정한다.   
근데 만약 다른 택시업체에서 `destination`을 `dest`와 같이 축약했다면?   
뻔한 일이지만, 이 예외사항을 처리하는 로직을 추가해야만 한다.   

이를 위한 가장 간단한 방법은 파견 명령어를 구성하는 모듈에 if문장을 추가하는 것이다.  

```java
if(driver.getDispatchUri().startsWith("acme.com"))...
```

하지만 실력있는 아키텍트라면 당연히 시스템을 이런식으로 구성하는 것을 용납하지마는 않는다.   
아키텍트는 이 같은 버그로부터 시스템을 격리해야한다.   
이때 URI를 키로 사용하는 설정요 데이터베이스를 이용하는 파견 명령 생성 모듈을 만들어야할 수도 있다.   

또한 아키텍트는 REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 중요하고 복잡한 매커니즘을 추가해야한다.  
  
# 결론 

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.        
치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야할 수 있기 때문이다.    
